<!--
 * @Author: your name
 * @Date: 2021-01-22 21:24:00
 * @LastEditTime: 2021-01-23 11:13:17
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \LinuxServerCodes\13\learnbook.md
-->
# 13 多进程编程
## 13.1 fork
```C++
pid_t fork(void);
```
fork函数的每次调用都返回两次，在父进程中返回的是子进程的PID，在子进程中则返回0。该返回值是后续代码判断当前进程是父进程还是子进程的依据。fork函数复制当前进程，在内核进程表中创建一个新的进程表项。数据的复制采用的是所谓的写时复制，即只有在任一进程对数据执行了写操作时，复制才会发生。
## 13.2 exec系列系统调用
有时我们需要在子进程中执行其他程序，即替换当前进程映像，这就需要exec系列函数之一。
## 13.3 处理僵尸进程
父进程一般需要跟踪子进程的退出状态。当子进程结束运行时，内核不会立即释放该进程的进程表表项以满足父进程后续对该子进程退出信息的查询。
- 子进程退出之后，父进程读取其退出状态之前称为僵尸态
- 父进程结束或异常终止，而子进程继续运行称为僵尸态。 
```C++
pid_t wait(int * stat_loc);
pid_t waitpid(pid_t pid,int* stat_loc,int options);
```
wait函数将阻塞进程，直到该进程的某个子进程结束运行位置。
waitpid可以是非阻塞的，我们可以在父进程中捕获SIGCHID信号，并在信号处理函数中调用waitpid来结束一个子进程。
## 13.4 管道
管道只能用于有关联的两个进程间通信（比如父进程和子进程）。有一种特殊的管道称为FIFO，也叫命名管道，可用于无关联进程间的通信，但是在网络编程中使用不多。
## 13.5 信号量
Linux信号量主要包括3个系统调用：`semget、semop、semctl`。他们被设计为操作一组信号量，即信号量集而不是单个信号量。

```C++
int semget(key_t key,int num_sems,int sem_flags);
```
semget系统调用创建了一个新的信号量集，或者获取一个已经存在的信号量集。

```C++
int semop(int sem_id,struct sembuf* sem_ops,size_t num_sem_ops);
```
semop系统调用改变信号量的值，即执行P、V操作。

```C++
int semctl(int sem_id,int sem_num,int command,...);
```
semctl系统调用允许调用者对信号量进行直接控制。
## 13.6 共享内存
共享内存是最高效的IPC机制，因此它不涉及进程之间的任何数据传输。我们通常用其他辅助手段来同步进程对共享内存的访问。主要包括4个系统调用,`shmget shmat shmdt shmctl`。
- shmget创建一段新的共享内存或者获取一段已经存在的共享内存
- 共享内存被创建获取后我们需要先将它关联到进程的地址空间，使用完还要从进程地址空间分离，分别用`shmat`和`shmdt`实现
- shmctl用来控制共享内存的某些属性
## 13.7 消息队列
消息队列是两个进程之间传递二进制块数据的一种简单有效的方式。每个数据块都有一个特定的类型，接收方可以根据类型来有选择的接受数据，而不一定像管道和命名管道那样必须以先进先出的方式接受数据。主要包括`msgget msgsnd msgrcv msgctl`。
- msgget创建或者获取一个消息队列
- msgsnd系统调用把一条消息添加到消息队列中
- msgrcv从消息队列中获取消息
- msgctl控制消息队列的某些属性
## 13.8 IPC命令
上述3种System V IPC进程间通信方式都使用一个全局唯一的键值(key)来描述一个共享资源。当程序调用了`semget shmget msgget`时，就创建了这些共享资源的一个实例。
## 13.9 在进程间传递文件描述符
传递一个文件描述符并不是传递一个文件描述符的值，而是要在接受进程中创建一个新的文件描述符，并且该文件描述符和发送进程中被传递的文件描述符指向内核中相同的文件表项。